# MapReduce: Simplified Data Processing on Large Clusters

MapReduce：简化大型集群的数据处理

## Abstract

MapReduce是一个编程模型，也是一个用于处理和生成大型数据集的相关实现。
用户指定一个映射函数，该函数处理一个键/值对以生成一组中间键/值对，以及一个 reduce 函数，该函数合并与同一中间键关联的所有中间值。
如论文所示，许多现实世界的任务都可以在这个模型中表达出来。
以这种功能样式编写的程序会自动并行化，并在大型商用机器集群上执行。
运行时系统负责对输入数据进行分区、在一组机器上调度程序执行、处理机器故障以及管理所需的机器间通信的细节。
这使得没有任何并行和分布式系统经验的程序员可以轻松利用大型分布式系统的资源。
我们的MapReduce实现在大型商用机器集群上运行，并且具有高度可扩展性：
典型的MapReduce计算在数千台机器上处理数TB的数据。
程序员发现该系统易于使用：已经实施了数百个MapReduce程序，每天在Google的集群上执行超过1000个MapReduce作业。

## 1 Introduction
在过去的五年中，作者和 Google 的许多其他人已经实现了数百种特殊用途的计算，
这些计算处理大量原始数据，例如爬取的文档、Web 请求日志等，
以计算各种派生数据，例如倒排索引、Web 文档图形结构的各种表示、 每个主机抓取的页面数摘要给定日期中最频繁的查询集，等等。
大多数此类计算在概念上都很简单。然而，输入数据通常很大，计算必须分布在数百或数千台机器上，以便在合理的时间内完成。
如何并行计算、分发数据和处理故障的问题，共同用大量复杂的代码来掩盖原始的简单计算，以处理这些问题。
作为对这种复杂性的回应，我们设计了一种新的抽象，它允许我们表达我们试图执行的简单计算，但隐藏了库中并行化、容错、数据分布和负载平衡等混乱的细节。我们的抽象受到 Map 和 Reduce 原语的启发，这些原语存在于 Lisp 和许多其他函数式语言中。
我们意识到，我们的大多数计算都涉及对输入中的每个逻辑“记录”应用映射操作，以计算一组中间键/值对，然后对共享同一键的所有值应用reduce操作，以便适当地组合派生数据。我们使用具有用户指定的 map 和 reduce 操作的函数模型，使我们能够轻松地并行化大型计算，并使用重新执行作为容错的主要机制。

这项工作的主要贡献是一个简单而强大的接口，它支持大规模计算的自动并行化和分布，并结合该接口的实现，在大型商用PC集群上实现高性能。


第 2 节介绍了基本的编程模型，并给出了几个示例。
第 3 节描述了MapReduce接口的实现，该接口是针对基于集群的计算环境量身定制的。
第 4 节描述了我们发现有用的编程模型的几个改进。
第 5 节对各种任务的实施进行了性能测量。
第 6 节探讨了 MapReduce 在 Google 中的使用，包括我们将其用作基础的经验重写我们的生产索引系统。
第 7 节讨论了相关工作和未来工作。


## 2 编程模型
MapReduce 程序是用户定义的 map 和 reduce 函数，它们在输入数据集上并行运行。
MapReduce采用一组输入键/值对，并生成一组输出键/值对。
MapReduce库的用户将计算表示为两个函数：Map和Reduce。

Map由用户编写采用一个输入对并生成一组中间键/值对。
MapReduce库将与同一中间键I关联的所有中间值组合在一起，并将它们传递给Reduce函数。

Reduce 函数也由用户编写，它接受中间键 I 和该键的一组值。
它将这些值合并在一起，以形成一组可能更小的值。

通常，每个 Reduce 调用仅生成零个或一个输出值。
中间值通过迭代器提供给用户的 reduce 函数。
这使我们能够处理太大而无法放入内存的值列表。

### 2.1 Example
```
map(String key, String value):
    // key: 文档名称 
    // value: 文档内容
    for each word w in value:
    EmitIntermediate(w, "1");
        

reduce(String key, Iterator values):
    // key: 一个字 
    // values：一个计数列表 
    int result = 0;
    for each v in values:
        result += ParseInt(v); 
      Emit(AsString(result));
```

map函数发出每个单词以及关联的出现次数（在这个简单示例中只是1）
reduce函数将特定单词发出的所有计数求和，并发出该单词的最终频率。


### 2.2 type

map(k1, v1) -> list(k2, v2)  

reduce(k2, list(v2)) -> list(v2) 

MapReduce执行概述
![](http://imgcom.static.suishenyun.net/202405161008157.png)


